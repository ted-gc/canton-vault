-- | Main Vault template implementing ERC-4626 vault logic
-- Supports both synchronous and asynchronous (EIP-7540) operations
module Splice.Vault.Vault where

import DA.Action (when, void)
import DA.Foldable (forA_)
import DA.Time
import DA.List (head)
import DA.Optional
import Splice.Vault.Types
import Splice.Vault.VaultShares qualified as Shares
import Splice.Vault.UnderlyingHolding qualified as Underlying

-- | Main vault contract
-- Manages deposits, withdrawals, and share accounting
template Vault
  with
    id : VaultId                       -- Vault identifier
    config : VaultConfig               -- Vault configuration
    state : VaultState                 -- Current state (assets, shares)
    meta : Metadata                    -- CIP-0056 metadata
  where
    signatory id.admin
    
    -- Vault key for lookups
    
    -- Ensure valid state
    ensure state.totalAssets >= 0.0 && state.totalShares >= 0.0

    -- ===== View Functions (ERC-4626) =====

    -- | Get current total assets under management
    nonconsuming choice GetTotalAssets : Decimal
      controller id.admin
      do return state.totalAssets

    -- | Get total shares outstanding
    nonconsuming choice GetTotalShares : Decimal
      controller id.admin
      do return state.totalShares

    -- | Get current share price
    nonconsuming choice GetSharePrice : Decimal
      controller id.admin
      do return $ sharePrice state

    -- | Convert assets to shares (preview)
    nonconsuming choice ConvertToShares : Decimal
      with
        assets : Decimal
      controller id.admin
      do return $ calculateShares assets state

    -- | Convert shares to assets (preview)
    nonconsuming choice ConvertToAssets : Decimal
      with
        shares : Decimal
      controller id.admin
      do return $ calculateAssets shares state

    -- | Maximum deposit allowed for a given receiver
    nonconsuming choice MaxDeposit : Decimal
      with
        receiver : Party
      controller id.admin
      do 
        case config.depositLimit of
          None -> return 999999999999.0  -- Effectively unlimited
          Some limit -> return $ max 0.0 (limit - state.totalAssets)

    -- | Maximum withdrawal for a given owner
    nonconsuming choice MaxWithdraw : Decimal
      with
        owner : Party
      controller id.admin
      do 
        -- Would need to query owner's actual holdings
        -- For now, return total assets as upper bound
        return state.totalAssets

    -- ===== Synchronous Operations (ERC-4626) =====

    -- | Deposit assets and receive shares
    -- Mints shares proportional to deposit relative to total assets
    choice Deposit : (ContractId Vault, ContractId Shares.VaultShareHolding, Decimal)
      with
        depositor : Party                                    -- Who is depositing
        depositAmount : Decimal                              -- Amount of underlying to deposit
        receiver : Party                                     -- Who receives shares
        depositReason : Text                                 -- Reason for deposit
        underlyingHoldingCid : ContractId Underlying.UnderlyingAssetHolding  -- CIP-0056 holding to consume
      controller depositor, id.admin
      do
        -- Validate deposit amount
        assertMsg "Deposit amount must be positive" (depositAmount > 0.0)
        assertMsg "Below minimum deposit" (depositAmount >= config.minDeposit)

        -- Fetch and validate underlying holding
        underlying <- fetch underlyingHoldingCid
        assertMsg "Not owner of underlying" (underlying.owner == depositor)
        assertMsg "Wrong asset type" (underlying.instrument == config.underlyingAsset)
        assertMsg "Underlying is locked" (isNone underlying.holdingLock)
        assertMsg "Insufficient underlying" (underlying.amount >= depositAmount)

        -- Check deposit limit
        maxDep <- exercise self MaxDeposit with receiver
        assertMsg "Exceeds deposit limit" (depositAmount <= maxDep)

        -- Calculate shares to mint
        let sharesToMint = calculateShares depositAmount state
        assertMsg "Would mint zero shares" (sharesToMint > 0.0)

        -- Transfer underlying to vault custody (CIP-0056 compliant)
        if underlying.amount == depositAmount
          then do
            exercise underlyingHoldingCid Underlying.Transfer with
              newOwner = id.admin
              reason = "Deposit to vault: " <> id.name
            return ()
          else do
            (depositCid, _changeCid) <- exercise underlyingHoldingCid Underlying.Split with
              splitAmount = depositAmount
              reason = depositReason
            exercise depositCid Underlying.Transfer with
              newOwner = id.admin
              reason = "Deposit to vault: " <> id.name
            return ()

        -- Mint shares for receiver
        now <- getTime
        sharesCid <- create Shares.VaultShareHolding with
          vault = id
          owner = receiver
          amount = sharesToMint
          holdingLock = None
          createdAt = now
          meta = setMetaValue txKindKey "mint" $
                 setMetaValue senderKey (partyToText depositor) $
                 setMetaValue reasonKey depositReason []

        -- Update vault state
        newVaultCid <- create this with
          state = state with
            totalAssets = state.totalAssets + depositAmount
            totalShares = state.totalShares + sharesToMint
            lastFeeAccrual = now

        return (newVaultCid, sharesCid, sharesToMint)

    -- | Mint exact shares by depositing required assets
    -- CIP-0056 compliant: takes underlying holding, may return change
    choice Mint : (ContractId Vault, ContractId Shares.VaultShareHolding, Decimal, Optional (ContractId Underlying.UnderlyingAssetHolding))
      with
        minter : Party
        sharesToMint : Decimal         -- Exact shares wanted
        receiver : Party
        underlyingHoldingCid : ContractId Underlying.UnderlyingAssetHolding
        mintReason : Text
      controller minter, id.admin
      do
        assertMsg "Shares must be positive" (sharesToMint > 0.0)

        -- Fetch underlying to check amount
        underlying <- fetch underlyingHoldingCid
        assertMsg "Not owner of underlying" (underlying.owner == minter)
        assertMsg "Wrong asset type" (underlying.instrument == config.underlyingAsset)

        -- Calculate assets required (round UP to favor vault)
        let assetsRequired = if state.totalShares == 0.0
              then sharesToMint
              else (sharesToMint * state.totalAssets / state.totalShares) + 0.0000000001

        assertMsg "Insufficient underlying for requested shares" (underlying.amount >= assetsRequired)

        -- Split if we have more than needed
        (depositCid, changeCid) <- if underlying.amount == assetsRequired
          then return (underlyingHoldingCid, None)
          else do
            (exactCid, changeCid) <- exercise underlyingHoldingCid Underlying.Split with
              splitAmount = assetsRequired
              reason = mintReason
            return (exactCid, Some changeCid)

        -- Deposit the exact amount
        (newVaultCid, sharesCid, actualShares) <- exercise self Deposit with
          depositor = minter
          depositAmount = assetsRequired
          receiver = receiver
          depositReason = mintReason
          underlyingHoldingCid = depositCid

        return (newVaultCid, sharesCid, actualShares, changeCid)

    -- | Redeem shares for underlying assets
    -- Burns shares and creates CIP-0056 underlying holding for receiver
    choice Redeem : (ContractId Vault, ContractId Underlying.UnderlyingAssetHolding, Decimal)
      with
        redeemer : Party
        sharesToRedeem : Decimal
        receiver : Party               -- Who receives the assets
        shareHoldingCid : ContractId Shares.VaultShareHolding
        redeemReason : Text
      controller redeemer, id.admin
      do
        -- Fetch and validate share holding
        shareHolding <- fetch shareHoldingCid
        assertMsg "Not owner of shares" (shareHolding.owner == redeemer)
        assertMsg "Wrong vault" (shareHolding.vault == id)
        assertMsg "Shares are locked" (isNone shareHolding.holdingLock)
        assertMsg "Insufficient shares" (shareHolding.amount >= sharesToRedeem)
        
        -- Calculate assets to return
        let assetsToReturn = calculateAssets sharesToRedeem state
        assertMsg "Would return zero assets" (assetsToReturn > 0.0)
        assertMsg "Vault has insufficient assets" (state.totalAssets >= assetsToReturn)
        
        now <- getTime
        
        -- Handle share holding - burn the redeemed shares
        if shareHolding.amount == sharesToRedeem
          then do
            -- Burn entire holding
            exercise shareHoldingCid Shares.Burn with reason = redeemReason
          else do
            -- Split and burn partial
            (burnCid, _keepCid) <- exercise shareHoldingCid Shares.Split with
              splitAmount = sharesToRedeem
              reason = redeemReason
            exercise burnCid Shares.Burn with reason = redeemReason
        
        -- Create underlying asset holding for receiver (CIP-0056 compliant)
        underlyingCid <- create Underlying.UnderlyingAssetHolding with
          instrument = config.underlyingAsset
          owner = receiver
          amount = assetsToReturn
          holdingLock = None
          createdAt = now
          meta = setMetaValue txKindKey "redeem" $
                 setMetaValue senderKey (partyToText redeemer) $
                 setMetaValue reasonKey redeemReason []
        
        -- Update vault state
        newVaultCid <- create this with
          state = state with
            totalAssets = state.totalAssets - assetsToReturn
            totalShares = state.totalShares - sharesToRedeem
            lastFeeAccrual = now
        
        return (newVaultCid, underlyingCid, assetsToReturn)

    -- | Withdraw exact assets by redeeming required shares
    choice Withdraw : (ContractId Vault, ContractId Underlying.UnderlyingAssetHolding, Decimal)
      with
        withdrawer : Party
        assetsToWithdraw : Decimal
        receiver : Party
        shareHoldingCid : ContractId Shares.VaultShareHolding
        withdrawReason : Text
      controller withdrawer, id.admin
      do
        assertMsg "Assets must be positive" (assetsToWithdraw > 0.0)
        assertMsg "Vault has insufficient assets" (state.totalAssets >= assetsToWithdraw)
        
        -- Calculate shares needed (round UP to favor vault)
        let sharesRequired = if state.totalAssets == 0.0
              then assetsToWithdraw
              else (assetsToWithdraw * state.totalShares / state.totalAssets) + 0.0000000001
        
        -- Redeem calculated shares
        exercise self Redeem with
          redeemer = withdrawer
          sharesToRedeem = sharesRequired
          receiver = receiver
          shareHoldingCid = shareHoldingCid
          redeemReason = withdrawReason

    -- ===== Admin Operations =====

    -- | Update vault configuration
    choice UpdateConfig : ContractId Vault
      with
        newConfig : VaultConfig
        updateReason : Text
      controller id.admin
      do
        now <- getTime
        let newMeta = setMetaValue reasonKey updateReason meta
        create this with
          config = newConfig
          state = state with lastFeeAccrual = now
          meta = newMeta

    -- | Accrue management fees (simplified - just updates timestamp)
    choice AccrueFees : ContractId Vault
      controller id.admin
      do
        now <- getTime
        -- Simplified fee accrual - full impl would calculate based on time elapsed
        create this with
          state = state with
            lastFeeAccrual = now


-- | Factory for creating new vaults
template VaultFactory
  with
    admin : Party                      -- Who can create vaults
    meta : Metadata
  where
    signatory admin

    -- | Create a new vault
    nonconsuming choice CreateVault : ContractId Vault
      with
        vaultName : Text
        vaultConfig : VaultConfig
      controller admin
      do
        now <- getTime
        let vaultId = VaultId with
              admin = admin
              name = vaultName
        
        create Vault with
          id = vaultId
          config = vaultConfig
          state = VaultState with
            totalAssets = 0.0
            totalShares = 0.0
            lastFeeAccrual = now
          meta = setMetaValue "splice.lfdecentralizedtrust.org/registry-urls" "" meta


-- Helper to convert microseconds to seconds
convertMicrosecondsToSeconds : Int -> Int
convertMicrosecondsToSeconds us = us / 1000000
