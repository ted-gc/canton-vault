-- | Vault share holding template
-- Implements CIP-0056 Holding interface for vault shares
module Splice.Vault.VaultShares where

import DA.Time
import DA.Optional
import Splice.Vault.Types

-- | Vault share holding - represents ownership in a vault
-- This template implements the CIP-0056 Holding interface, making
-- vault shares interoperable with any Canton wallet and DVP settlement
template VaultShareHolding
  with
    vault : VaultId                    -- Which vault these shares belong to
    owner : Party                      -- Current owner of the shares
    amount : Decimal                   -- Number of shares held
    holdingLock : Optional HoldingLock        -- Optional lock for DVP allocation
    createdAt : Time                   -- When this holding was created
    meta : Metadata                    -- CIP-0056 metadata
  where
    signatory vault.admin, owner
    
    -- Ensure positive amount
    ensure amount > 0.0

    -- | View for CIP-0056 Holding interface
    -- Wallets read this to display share balances
    -- Note: Contract keys removed for Daml 3.x compatibility

    -- | Get the instrument ID for these shares
    nonconsuming choice GetInstrumentId : InstrumentId
      controller vault.admin
      do return InstrumentId with
           admin = vault.admin
           id = vault.name <> "-VAULT-SHARES"

    -- | Check if holding is locked
    nonconsuming choice IsLocked : Bool
      controller vault.admin
      do return $ isSome holdingLock

    -- | Split holding into two (for partial transfers/redemptions)
    choice Split : (ContractId VaultShareHolding, ContractId VaultShareHolding)
      with
        splitAmount : Decimal
        reason : Text
      controller owner
      do
        assertMsg "Holding is locked" (isNone holdingLock)
        assertMsg "Split amount must be positive" (splitAmount > 0.0)
        assertMsg "Split amount must be less than total" (splitAmount < amount)
        
        now <- getTime
        let newMeta = setMetaValue txKindKey "merge-split" $
                      setMetaValue reasonKey reason meta
        
        -- Create two new holdings
        h1 <- create this with 
          amount = splitAmount
          createdAt = now
          meta = newMeta
        
        h2 <- create this with 
          amount = amount - splitAmount
          createdAt = now
          meta = newMeta
        
        return (h1, h2)

    -- | Merge with another holding of the same owner
    choice Merge : ContractId VaultShareHolding
      with
        otherCid : ContractId VaultShareHolding
        reason : Text
      controller owner
      do
        assertMsg "Holding is locked" (isNone holdingLock)
        
        other <- fetch otherCid
        assertMsg "Same vault required" (other.vault == vault)
        assertMsg "Same owner required" (other.owner == owner)
        assertMsg "Other holding is locked" (isNone other.holdingLock)
        
        archive otherCid
        
        now <- getTime
        let newMeta = setMetaValue txKindKey "merge-split" $
                      setMetaValue reasonKey reason meta
        
        create this with 
          amount = amount + other.amount
          createdAt = now
          meta = newMeta

    -- | Lock holding for DVP allocation
    choice Lock : ContractId VaultShareHolding
      with
        lockHolder : Party
        context : Text
        expiresAt : Optional Time
      controller owner, lockHolder
      do
        assertMsg "Already locked" (isNone holdingLock)
        
        now <- getTime
        let newLock = HoldingLock with
              lockHolder = lockHolder
              context = context
              expiresAt = expiresAt
        let newMeta = setMetaValue "splice.lfdecentralizedtrust.org/lock-context" context meta
        
        create this with
          holdingLock = Some newLock
          createdAt = now
          meta = newMeta

    -- | Unlock holding (by lock holder or after expiry)
    choice Unlock : ContractId VaultShareHolding
      with
        reason : Text
      controller vault.admin
      do
        case holdingLock of
          None -> abort "Not locked"
          Some l -> do
            now <- getTime
            -- Check if lock holder or expired
            let expired = case l.expiresAt of
                  None -> False
                  Some exp -> now > exp
            -- For now, only vault admin can unlock (simplification)
            let newMeta = setMetaValue txKindKey "unlock" $
                          setMetaValue reasonKey reason meta
            create this with
              holdingLock = None
              createdAt = now
              meta = newMeta

    -- | Transfer shares to another party
    -- This is the direct transfer choice for FOP transfers
    choice Transfer : ContractId VaultShareHolding
      with
        newOwner : Party
        reason : Text
      controller owner, newOwner
      do
        assertMsg "Holding is locked" (isNone holdingLock)
        assertMsg "Cannot transfer to self" (newOwner /= owner)
        
        now <- getTime
        let newMeta = setMetaValue txKindKey "transfer" $
                      setMetaValue senderKey (partyToText owner) $
                      setMetaValue reasonKey reason meta
        
        create this with
          owner = newOwner
          createdAt = now
          meta = newMeta

    -- | Burn shares (used during redemption)
    -- Only vault admin can burn as part of redemption process
    choice Burn : ()
      with
        reason : Text
      controller vault.admin, owner
      do
        assertMsg "Holding is locked" (isNone holdingLock)
        -- Archive happens automatically
        return ()


-- | Factory for creating vault share holdings
-- Used by the vault when minting new shares on deposit
template VaultShareFactory
  with
    vault : VaultId
    meta : Metadata
  where
    signatory vault.admin

    -- | Mint new shares for a depositor
    nonconsuming choice MintShares : ContractId VaultShareHolding
      with
        recipient : Party
        shareAmount : Decimal
        mintReason : Text
      controller vault.admin
      do
        assertMsg "Amount must be positive" (shareAmount > 0.0)
        
        now <- getTime
        let mintMeta = setMetaValue txKindKey "mint" $
                       setMetaValue reasonKey mintReason meta
        
        create VaultShareHolding with
          vault = vault
          owner = recipient
          amount = shareAmount
          holdingLock = None
          createdAt = now
          meta = mintMeta
